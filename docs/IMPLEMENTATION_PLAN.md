# Alpha Board — Implementation Plan

**Created:** 2026-02-04
**Reference:** PRD v2.0, Technical Spec v1.0

---

## Overview

This plan breaks the Alpha Board project into **14 phases** organized into **4 stages**. Each phase is designed to be completable in a single focused session and produces a testable deliverable.

**Critical path:** Phases are sequential within each stage, but Stage C (Agent Backend) can begin once Stage A is complete, in parallel with Stage B (Frontend).

```
Stage A: Foundation          Stage B: Rankings Frontend    Stage C: Agent Backend    Stage D: Agent Frontend
─────────────────────        ─────────────────────────     ──────────────────────    ─────────────────────
Phase 1: Scaffolding    ──→  Phase 7: Rankings UI     ──→  Phase 11: Agent UI
Phase 2: DB Schema      │    Phase 8: Rankings Polish       Phase 12: Agent Detail
Phase 3: Binance Client │
Phase 4: Indicators     │    Phase 5: Scoring & Ranking
Phase 5: Scoring        │    Phase 6: Pipeline Runner  ──→  Phase 9: Agent Core
Phase 6: Pipeline       │                                   Phase 10: Agent Learning
                        │
                        └──→ Phase 13: Deployment
                             Phase 14: Testing & Polish
```

---

## Stage A: Foundation (Phases 1–6)

### Phase 1: Project Scaffolding & Infrastructure

**Goal:** Set up the monorepo structure with both `worker/` and `web/` projects, all config files, and local development tooling.

**Deliverables:**
- [ ] `worker/pyproject.toml` with all Python dependencies
- [ ] `worker/src/` directory structure matching Technical Spec §2.1
- [ ] `worker/src/config.py` — Settings loaded from env vars (Pydantic Settings)
- [ ] `worker/src/db.py` — SQLAlchemy async engine + session factory
- [ ] `worker/alembic.ini` + `worker/alembic/env.py` — Alembic configured for async
- [ ] `worker/Dockerfile` — Multi-stage build for production
- [ ] `web/` — Next.js 15 App Router project (`create-next-app` with TypeScript, Tailwind, ESLint)
- [ ] `web/src/lib/db.ts` — Neon serverless driver connection
- [ ] `.env.example` at root with all required env vars documented
- [ ] `.gitignore` updated for both Python and Node.js artifacts
- [ ] Verify: `pip install -e .` works in worker/, `npm run dev` works in web/

**Key decisions:**
- Use `uv` or `pip` for Python dependency management
- Neon serverless driver (`@neondatabase/serverless`) for web/

**Files created:**
```
worker/
  pyproject.toml
  Dockerfile
  alembic.ini
  alembic/env.py
  src/__init__.py
  src/main.py          (stub: FastAPI + scheduler setup)
  src/config.py
  src/db.py
  src/exchange/__init__.py
  src/indicators/__init__.py
  src/scoring/__init__.py
  src/agents/__init__.py
  src/pipeline/__init__.py
  src/models/__init__.py
  src/models/db.py     (stub: imports only)

web/
  (generated by create-next-app)
  src/lib/db.ts
  src/lib/types.ts     (stub)
  src/lib/utils.ts     (stub)

.env.example
```

---

### Phase 2: Database Schema & Migrations

**Goal:** Create all database tables via Alembic migrations and define SQLAlchemy ORM models. Seed the 28 agents.

**Depends on:** Phase 1

**Deliverables:**
- [ ] Migration 001: `symbols`, `indicators`, `computation_runs`, `snapshots` (with partitions)
- [ ] Migration 002: All agent tables (`agents`, `agent_prompts`, `agent_portfolios`, `agent_positions`, `agent_trades`, `agent_decisions` with partitions, `agent_memory`, `agent_token_usage`)
- [ ] Migration 003: Seed 28 agents with initial prompts + portfolio initialization + seed indicators with default weights
- [ ] `worker/src/models/db.py` — Full SQLAlchemy ORM models for all 12 tables
- [ ] Verify: `alembic upgrade head` runs cleanly against a fresh Neon database (or local PG)

**Key decisions:**
- Partition naming convention: `tablename_YYYY_MM`
- Indicator seed data: 9 indicators with weights from PRD §10

**Files created/modified:**
```
worker/alembic/versions/
  001_initial_schema.py
  002_agent_tables.py
  003_seed_data.py

worker/src/models/db.py    (full ORM models)
```

---

### Phase 3: Binance Client (Data Ingestion)

**Goal:** Build the HTTP client that fetches market data from Binance with proper rate limiting and error handling.

**Depends on:** Phase 1

**Deliverables:**
- [ ] `worker/src/exchange/types.py` — Pydantic models for Symbol, Candle, OHLCV DataFrame schema
- [ ] `worker/src/exchange/client.py` — `BinanceClient` class with:
  - `get_active_symbols(min_volume_usd)` — Fetch all USDT spot pairs above volume threshold
  - `get_klines(symbol, interval, limit)` — Fetch OHLCV candles for a single symbol
  - `get_klines_batch(symbols, interval, limit)` — Batch fetch with concurrency control (10 concurrent) and rate limiting (1200 req/min)
- [ ] Rate limiting via `asyncio.Semaphore` + token bucket or simple delay
- [ ] Retry logic: 3x exponential backoff for timeouts, respect `Retry-After` for 429s
- [ ] Unit tests with mocked HTTP responses
- [ ] Verify: can fetch real data from Binance API for 5 symbols

**Files created:**
```
worker/src/exchange/types.py
worker/src/exchange/client.py
worker/tests/test_exchange.py
```

---

### Phase 4: Indicator Computation

**Goal:** Implement all 9 technical indicators, signal normalization, and highlight chip generation.

**Depends on:** Phase 3 (needs OHLCV DataFrame format)

**Deliverables:**
- [ ] `worker/src/indicators/compute.py` — Individual indicator computation functions:
  - `compute_rsi(df, period=14)` → float
  - `compute_macd(df, fast=12, slow=26, signal=9)` → dict (macd, signal, histogram)
  - `compute_stochastic(df, k=14, d=3, smooth=3)` → dict (k, d)
  - `compute_adx(df, period=14)` → dict (adx, plus_di, minus_di)
  - `compute_obv(df)` → dict (obv, slope)
  - `compute_bollinger(df, period=20, std=2)` → dict (upper, middle, lower, bandwidth, position)
  - `compute_ema(df, period)` → dict (ema, price_vs_ema_pct)
- [ ] `worker/src/indicators/signals.py` — Signal normalization functions per indicator (using configurable thresholds from DB)
- [ ] `worker/src/indicators/registry.py` — `IndicatorRegistry` class: register, compute_all, dispatch
- [ ] `worker/src/indicators/highlights.py` — Generate highlight chips (max 4 per symbol)
- [ ] Unit tests for each indicator computation + signal normalization
- [ ] Verify: compute all indicators for BTCUSDT 1H candles, inspect output

**Key decisions:**
- Use `pandas-ta` for computation where possible, custom code where needed
- Signal normalization rules from PRD Appendix B

**Files created:**
```
worker/src/indicators/compute.py
worker/src/indicators/signals.py
worker/src/indicators/registry.py
worker/src/indicators/highlights.py
worker/tests/test_indicators.py
```

---

### Phase 5: Scoring & Ranking

**Goal:** Implement composite bullish score, confidence score, and ranking logic.

**Depends on:** Phase 4

**Deliverables:**
- [ ] `worker/src/scoring/scorer.py` — `BullishScorer`:
  - Weighted average of signals, rescaled from [-1, +1] to [0, 1]
  - Reads weights from DB (`indicators` table)
- [ ] `worker/src/scoring/confidence.py` — `ConfidenceScorer`:
  - Signal agreement (60%): based on standard deviation of signal values
  - Data completeness (25%): penalizes missing indicators
  - Volume adequacy (15%): percentile rank of 24h volume
- [ ] `worker/src/scoring/ranker.py` — `Ranker`:
  - Rank all symbols by bullish_score DESC, confidence DESC (tiebreaker)
  - Produce snapshot rows ready for DB insert
- [ ] Unit tests for scoring edge cases (all bullish, all bearish, mixed, missing indicators)
- [ ] Verify: score and rank a sample of 10 symbols, validate output range and ordering

**Files created:**
```
worker/src/scoring/scorer.py
worker/src/scoring/confidence.py
worker/src/scoring/ranker.py
worker/tests/test_scoring.py
```

---

### Phase 6: Rankings Pipeline Orchestration

**Goal:** Wire everything together into a runnable pipeline with scheduling, locking, and health checks.

**Depends on:** Phases 2, 3, 4, 5

**Deliverables:**
- [ ] `worker/src/pipeline/runner.py` — `PipelineRunner`:
  - Full pipeline: fetch OHLCV → compute indicators → score → rank → persist snapshots
  - Create `computation_run` row (running → completed/failed)
  - Advisory lock (`pg_try_advisory_lock`) to prevent overlapping runs
  - Error handling: partial failures don't kill the run
- [ ] `worker/src/main.py` — Complete entrypoint:
  - FastAPI app with `/health`, `/status`, `/trigger/{timeframe}` endpoints
  - APScheduler: runs every 5 minutes, checks which timeframes are due
  - Timeframe cadence logic (15m→every 5 min, 30m→every 10 min, etc.)
- [ ] Candle close detection for agent triggering (stub: log that agents would run)
- [ ] Verify: run full pipeline for 1H timeframe against real Binance data, inspect DB rows

**Files created/modified:**
```
worker/src/pipeline/runner.py
worker/src/main.py             (complete implementation)
worker/tests/test_pipeline.py
```

**Milestone:** At this point, the rankings backend is functional. You can run `python -m src.main` and it will periodically fetch data, compute indicators, score, rank, and persist snapshots.

---

## Stage B: Rankings Frontend (Phases 7–8)

### Phase 7: Rankings UI — Core

**Goal:** Build the rankings page with table, timeframe switching, and basic functionality.

**Depends on:** Phase 2 (DB schema), Phase 6 (data in DB)

**Deliverables:**
- [ ] Install and configure shadcn/ui (Table, Badge, Input, Tabs components)
- [ ] `web/src/lib/queries/rankings.ts` — `getAllTimeframeRankings()` query (fetches all 6 TFs in parallel)
- [ ] `web/src/lib/types.ts` — TypeScript types matching DB schema (Snapshot, RankingRow, Timeframe, etc.)
- [ ] `web/src/app/page.tsx` — Server component: fetch all timeframes, pass to client
- [ ] `web/src/components/rankings/rankings-table.tsx` — Client component: timeframe switching is purely client-side state change (no network request)
- [ ] `web/src/components/rankings/timeframe-selector.tsx` — 6 timeframe buttons/tabs
- [ ] `web/src/components/rankings/ranking-row.tsx` — Table row with rank, symbol, score, confidence
- [ ] `web/src/components/rankings/score-bar.tsx` — Visual bar for bullish score (0–1)
- [ ] `web/src/components/rankings/highlight-chip.tsx` — Colored chips for highlights
- [ ] `web/src/hooks/use-timeframe.ts` — Client state for selected timeframe
- [ ] Verify: page loads with real data, timeframe switching is instant (<200ms)

**Files created:**
```
web/src/lib/queries/rankings.ts
web/src/lib/types.ts
web/src/app/page.tsx
web/src/app/layout.tsx          (updated with navigation)
web/src/components/rankings/rankings-table.tsx
web/src/components/rankings/timeframe-selector.tsx
web/src/components/rankings/ranking-row.tsx
web/src/components/rankings/score-bar.tsx
web/src/components/rankings/highlight-chip.tsx
web/src/hooks/use-timeframe.ts
```

---

### Phase 8: Rankings UI — Polish

**Goal:** Add remaining features: row expansion, search, sort, last-updated timestamp, and ISR config.

**Depends on:** Phase 7

**Deliverables:**
- [ ] `web/src/components/rankings/indicator-breakdown.tsx` — Expandable per-indicator signal breakdown (bullish/neutral/bearish badges with raw values)
- [ ] Row expand/collapse behavior in `ranking-row.tsx`
- [ ] Client-side search filter (by symbol name) in `rankings-table.tsx`
- [ ] Client-side sort (by score, confidence, symbol) in `rankings-table.tsx`
- [ ] "Last updated: [timestamp] ([relative time])" display
- [ ] ISR revalidation configured per-timeframe (60s for 15m, up to 3600s for 1W)
- [ ] Responsive layout (usable on tablet/mobile widths)
- [ ] Verify: all interactions work smoothly, data displays correctly

**Files created/modified:**
```
web/src/components/rankings/indicator-breakdown.tsx
web/src/components/rankings/rankings-table.tsx   (search + sort)
web/src/components/rankings/ranking-row.tsx      (expand/collapse)
web/src/app/page.tsx                             (ISR config)
```

**Milestone:** Rankings frontend is complete. Users can browse, switch timeframes, search, sort, and inspect indicator breakdowns.

---

## Stage C: Agent Backend (Phases 9–10)

### Phase 9: Agent System — Core

**Goal:** Build the agent decision-making pipeline: context building, Claude API calls, portfolio management, and the orchestrator.

**Depends on:** Phase 6 (pipeline produces data agents consume)

**Deliverables:**
- [ ] `worker/src/agents/schemas.py` — Pydantic models for AgentAction, AgentDecision, AgentContext, PortfolioSummary, PerformanceStats
- [ ] `worker/src/agents/context.py` — `ContextBuilder`: assembles agent context from rankings, OHLCV, indicators, portfolio, memory
- [ ] `worker/src/agents/executor.py` — `AgentExecutor`:
  - `decide()`: call Claude API with tool_use (`trade_action` tool), parse structured response + reasoning text
  - Token usage extraction from API response
  - Retry on timeout (once)
- [ ] `worker/src/agents/portfolio.py` — `PortfolioManager`:
  - `open_position()`: validate constraints (max size 25%, max 5 concurrent, sufficient cash), create position, deduct cash + fees
  - `close_position()`: calculate PnL, update portfolio, create trade record
  - `update_unrealized_pnl()`: update all open positions with current prices
  - `check_stop_loss_take_profit()`: evaluate open positions against candle high/low
  - Action validation (separate from execution)
- [ ] `worker/src/agents/orchestrator.py` — `AgentOrchestrator`:
  - `run_cycle(timeframe)`: sequential execution of all active agents for a timeframe
  - Decision logging to `agent_decisions`
  - Token tracking to `agent_token_usage`
  - Candle close detection integration
- [ ] Cross-timeframe context builder (confluence, divergence detection)
- [ ] Wire agent orchestrator into `pipeline/runner.py` (run agents after rankings persist)
- [ ] Verify: run a full cycle for 1H agents with real data, inspect decisions in DB

**Key decisions:**
- Tool definition matches Technical Spec §8.1
- Memory and evolution are stubs in this phase (wired in Phase 10)

**Files created/modified:**
```
worker/src/agents/schemas.py
worker/src/agents/context.py
worker/src/agents/executor.py
worker/src/agents/portfolio.py
worker/src/agents/orchestrator.py
worker/src/pipeline/runner.py    (agent integration)
worker/tests/test_agents.py
```

---

### Phase 10: Agent System — Learning & Evolution

**Goal:** Implement memory bank, prompt evolution, auto-revert, and prompt version management.

**Depends on:** Phase 9

**Deliverables:**
- [ ] `worker/src/agents/memory.py` — `MemoryManager`:
  - `generate_memory(agent, trade)`: call Claude (scan_model) to produce a 1-3 sentence reflection
  - `get_recent_memory(agent_id, limit=20)`: fetch latest memory entries for context injection
  - Memory tagging (auto-tag with symbol, outcome, strategy-relevant labels)
- [ ] `worker/src/agents/evolution.py` — `EvolutionManager`:
  - `trigger_evolution(agent_id)`: meta-prompt sends performance stats + current prompt, asks Claude (evolution_model) to propose revisions
  - Save new prompt version (`source: auto`) with diff
  - Activate new prompt, deactivate old
  - Auto-revert logic: if PnL drops >20% after evolution, revert to previous prompt
  - Track evolution threshold (trigger after N closed trades)
- [ ] Integrate memory into agent context (inject last 20 entries)
- [ ] Integrate evolution into orchestrator (trigger after trade closes, check threshold)
- [ ] Cost estimation function (model pricing table from Tech Spec §6.4)
- [ ] Verify: close a trade manually, verify memory is generated; trigger evolution after threshold, verify prompt updates

**Files created/modified:**
```
worker/src/agents/memory.py
worker/src/agents/evolution.py
worker/src/agents/orchestrator.py  (memory + evolution integration)
worker/src/agents/context.py       (memory injection)
worker/tests/test_evolution.py
```

**Milestone:** Agent backend is fully functional. 28 agents make decisions, manage portfolios, learn from trades, and evolve their strategies autonomously.

---

## Stage D: Agent Frontend (Phases 11–12)

### Phase 11: Agent Leaderboard

**Goal:** Build the agent leaderboard page with all metrics, sorting, and filtering.

**Depends on:** Phase 2 (DB schema), Phase 9 (agent data in DB)

**Deliverables:**
- [ ] `web/src/lib/queries/agents.ts` — Queries:
  - `getAgentLeaderboard()`: all 28 agents with PnL, win rate, drawdown, trade count, token cost, open positions
  - `getAgentDetail(agentId)`: single agent with full detail
- [ ] `web/src/app/agents/page.tsx` — Server component: fetch leaderboard, ISR 60s
- [ ] `web/src/components/agents/agent-leaderboard.tsx` — Client component: sortable table
- [ ] `web/src/components/agents/agent-row.tsx` — Row with: name, archetype badge, timeframe, PnL (colored), win rate, trades, models, token cost, status
- [ ] Timeframe filter (15m, 30m, 1h, 4h, 1d, 1w, cross-TF)
- [ ] Archetype filter (momentum, mean-reversion, breakout, swing)
- [ ] Client-side sorting by any metric column
- [ ] Pause/Resume toggle (calls API to update agent status)
- [ ] `web/src/app/api/agents/[agentId]/status/route.ts` — POST: toggle pause/resume
- [ ] Navigation: add "Rankings" / "Agents" nav links to layout
- [ ] Verify: leaderboard loads with agent data, sorting and filtering work

**Files created:**
```
web/src/lib/queries/agents.ts
web/src/app/agents/page.tsx
web/src/components/agents/agent-leaderboard.tsx
web/src/components/agents/agent-row.tsx
web/src/app/api/agents/[agentId]/status/route.ts
web/src/app/layout.tsx                           (nav update)
```

---

### Phase 12: Agent Detail Page

**Goal:** Build the full agent detail page with all 5 tabs.

**Depends on:** Phase 11

**Deliverables:**
- [ ] `web/src/app/agents/[agentId]/page.tsx` — Server component: fetch agent data, ISR 30s
- [ ] Additional queries in `agents.ts`:
  - `getAgentTrades(agentId)`: full trade history with reasoning summaries
  - `getAgentDecisions(agentId)`: all decisions including holds
  - `getAgentPromptHistory(agentId)`: all prompt versions
  - `getAgentTokenUsage(agentId)`: usage breakdown by model × task type
  - `getAgentOpenPositions(agentId)`: current open positions with unrealized PnL

**Tab implementations:**

- [ ] **Overview tab** (`agent-overview.tsx`):
  - Equity curve (simple line chart — use a lightweight chart lib or SVG)
  - Metrics grid: Total PnL, Win Rate, Max Drawdown, Sharpe-like ratio, Total Trades, Token Cost
  - Open positions table with unrealized PnL

- [ ] **Trade History tab** (`trade-history.tsx`):
  - Sortable table: symbol, direction (long/short badge), entry/exit price, position size, PnL (colored), duration, reasoning summary
  - Expandable rows: show full verbatim Claude response

- [ ] **Reasoning Log tab** (`reasoning-log.tsx`):
  - Chronological list of all decisions (including holds)
  - Filter by action type (open_long, open_short, close, hold)
  - Search within reasoning text
  - Each entry: timestamp, action, symbol, confidence, summary (expandable to full response)

- [ ] **Strategy Prompt tab** (`prompt-editor.tsx` + `prompt-history.tsx`):
  - Textarea editor with current active prompt
  - Save button → calls `POST /api/agents/[agentId]/prompt`
  - Below editor: version history timeline
  - Each version: version number, source badge (initial/auto/human), date, performance snapshot
  - Diff view between consecutive versions

- [ ] **Model Config tab** (`model-config.tsx`):
  - 3 dropdowns: scan_model, trade_model, evolution_model
  - Save button → calls API to update agent model config
  - Token usage breakdown table: model × task_type × tokens × cost
  - `web/src/app/api/agents/[agentId]/models/route.ts` — POST: save model config

- [ ] `web/src/app/api/agents/[agentId]/prompt/route.ts` — POST: save prompt edit (from Tech Spec §9.6)

- [ ] Equity chart component (`equity-chart.tsx`) — derive from trade history (starting balance → apply each trade PnL)

- [ ] Verify: all tabs render with data, prompt editing saves, model config saves

**Files created:**
```
web/src/app/agents/[agentId]/page.tsx
web/src/components/agents/agent-overview.tsx
web/src/components/agents/trade-history.tsx
web/src/components/agents/reasoning-log.tsx
web/src/components/agents/prompt-editor.tsx
web/src/components/agents/prompt-history.tsx
web/src/components/agents/model-config.tsx
web/src/components/agents/equity-chart.tsx
web/src/app/api/agents/[agentId]/prompt/route.ts
web/src/app/api/agents/[agentId]/models/route.ts
```

**Milestone:** Full frontend complete. Users can browse rankings, compare agents on the leaderboard, inspect every trade and decision, edit prompts, and configure models.

---

## Stage E: Deployment & Hardening (Phases 13–14)

### Phase 13: Deployment

**Goal:** Deploy all three components to production infrastructure.

**Depends on:** All previous phases

**Deliverables:**
- [ ] **Neon database:**
  - Create production database on Neon
  - Run all migrations
  - Configure connection pooling
  - Set up dev branch for development

- [ ] **Python Worker (Fly.io):**
  - `fly.toml` configuration (from Tech Spec §10.1)
  - Deploy Dockerfile
  - Set environment variables (secrets)
  - Verify health check endpoint
  - Verify scheduled pipeline runs

- [ ] **Next.js Frontend (Vercel):**
  - Connect Git repo to Vercel
  - Set `web/` as root directory
  - Configure environment variables
  - Verify ISR works (check revalidation)
  - Custom domain (if applicable)

- [ ] **Monitoring:**
  - Verify Fly.io logs capture structured JSON logs
  - Verify health check alerts

- [ ] **Retention cleanup:**
  - Wire the daily cleanup job (drop old partitions, create new ones)
  - Verify partition management works

**Files created/modified:**
```
worker/fly.toml
web/vercel.json
```

---

### Phase 14: Testing, Hardening & Polish

**Goal:** End-to-end verification, performance tuning, error handling review, and final polish.

**Depends on:** Phase 13

**Deliverables:**
- [ ] **End-to-end test:** run full pipeline → verify rankings appear in frontend → verify agents make decisions → verify leaderboard updates
- [ ] **Performance:**
  - Verify timeframe switching <200ms (all data prefetched)
  - Verify page LCP <2s
  - Verify agent leaderboard loads <1s
  - Bundle analysis (`next build` output)
- [ ] **Error handling review:**
  - Simulate Binance API failure → verify graceful degradation
  - Simulate Claude API failure → verify hold logged
  - Simulate DB connection failure → verify frontend shows stale data
- [ ] **Security checklist:**
  - No hardcoded secrets in codebase
  - Environment variables for all config
  - Prompt edit endpoint validates input
  - SQL injection prevention (parameterized queries)
- [ ] **Disclaimers:**
  - Add "SIMULATED TRADING" disclaimer to agent pages
  - Add "Not financial advice" notice
- [ ] **UI polish:**
  - Dark mode (decide: dark-only or toggle)
  - Loading states for all data fetches
  - Error states for failed fetches
  - Empty states for agents with no trades
- [ ] **Documentation:**
  - README.md with setup instructions
  - Env var documentation
  - Contributing guide (if applicable)

---

## Dependency Graph (Simplified)

```
Phase 1 (Scaffolding)
├── Phase 2 (DB Schema)
│   ├── Phase 7 (Rankings UI Core) ──→ Phase 8 (Rankings UI Polish)
│   └── Phase 11 (Agent Leaderboard) ──→ Phase 12 (Agent Detail)
├── Phase 3 (Binance Client)
│   └── Phase 4 (Indicators)
│       └── Phase 5 (Scoring)
│           └── Phase 6 (Pipeline)
│               ├── Phase 7 (Rankings UI Core)
│               └── Phase 9 (Agent Core)
│                   └── Phase 10 (Agent Learning)
│                       └── Phase 11 (Agent Leaderboard)
└── Phase 13 (Deployment) ──→ Phase 14 (Testing)
```

## Phase Priority Order (Recommended)

If executing strictly sequentially, this is the recommended order:

| Order | Phase | Cumulative Result |
|-------|-------|-------------------|
| 1 | Phase 1: Scaffolding | Runnable dev environment |
| 2 | Phase 2: DB Schema | Database ready with seed data |
| 3 | Phase 3: Binance Client | Can fetch live market data |
| 4 | Phase 4: Indicators | Can compute all 9 indicators |
| 5 | Phase 5: Scoring | Can score and rank symbols |
| 6 | Phase 6: Pipeline | **Rankings backend live** — running on schedule |
| 7 | Phase 7: Rankings UI Core | **Rankings frontend MVP** — viewable in browser |
| 8 | Phase 8: Rankings UI Polish | Rankings frontend complete |
| 9 | Phase 9: Agent Core | Agents making decisions |
| 10 | Phase 10: Agent Learning | Agents evolving autonomously |
| 11 | Phase 11: Agent Leaderboard | **Agent frontend MVP** — leaderboard live |
| 12 | Phase 12: Agent Detail | Agent frontend complete |
| 13 | Phase 13: Deployment | Live in production |
| 14 | Phase 14: Testing & Polish | Production-ready |

---

## Open Decisions (To Resolve During Implementation)

| # | Decision | Options | Resolve In |
|---|----------|---------|------------|
| 1 | Python package manager | `uv` (fast) vs `pip` (standard) | Phase 1 |
| 2 | Dark mode approach | Dark-only vs toggle | Phase 7 |
| 3 | Chart library for equity curve | Recharts, Chart.js, or pure SVG | Phase 12 |
| 4 | Exclude stablecoins from rankings? | Yes (cleaner) vs No (complete) | Phase 3 |
| 5 | 15m computation frequency | Every 5 min (spec) vs every 15 min (simpler) | Phase 6 |
| 6 | Multiple positions per symbol per agent? | Yes (flexible) vs No (simpler) | Phase 9 |
| 7 | Per-agent daily cost ceiling with auto-pause? | Yes (safety) vs No (simpler v1) | Phase 10 |

---

## Estimated Complexity Per Phase

| Phase | Files | Complexity | Notes |
|-------|-------|-----------|-------|
| 1. Scaffolding | ~20 | Low | Boilerplate, config |
| 2. DB Schema | ~5 | Medium | Complex schema, partitioning |
| 3. Binance Client | ~3 | Medium | Rate limiting, error handling |
| 4. Indicators | ~5 | Medium-High | 9 indicators, signal logic |
| 5. Scoring | ~4 | Medium | Scoring math, edge cases |
| 6. Pipeline | ~3 | Medium | Orchestration, locking |
| 7. Rankings UI Core | ~10 | Medium | Data table, timeframe switching |
| 8. Rankings UI Polish | ~4 | Low-Medium | Search, sort, expand |
| 9. Agent Core | ~6 | **High** | Claude API integration, portfolio management, validation |
| 10. Agent Learning | ~3 | Medium-High | Evolution logic, auto-revert |
| 11. Agent Leaderboard | ~5 | Medium | Queries, filters, sorting |
| 12. Agent Detail | ~10 | **High** | 5 tabs, prompt editing, charts |
| 13. Deployment | ~3 | Medium | Infra setup, env management |
| 14. Testing & Polish | ~5 | Medium | E2E verification, UI polish |

---

*This plan is a living document. Update as decisions are made and phases are completed.*
